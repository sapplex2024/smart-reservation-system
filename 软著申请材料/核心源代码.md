# 智能预约系统核心源代码

## 1. 前端核心代码

### 1.1 主应用入口 (main.ts)

```typescript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import * as ElementPlusIconsVue from '@element-plus/icons-vue'
import App from './App.vue'
import router from './router'

const app = createApp(App)

// 注册Element Plus图标
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component)
}

app.use(createPinia())
app.use(router)
app.use(ElementPlus)

app.mount('#app')
```

### 1.2 智能对话组件 (ChatView.vue)

```vue
<template>
  <div class="chat-container">
    <div class="chat-header">
      <h2>智能预约助手</h2>
      <el-button @click="toggleVoice" :type="isVoiceMode ? 'primary' : 'default'">
        <el-icon><Microphone /></el-icon>
        {{ isVoiceMode ? '关闭语音' : '开启语音' }}
      </el-button>
    </div>
    
    <div class="chat-messages" ref="messagesContainer">
      <div v-for="message in messages" :key="message.id" 
           :class="['message', message.type]">
        <div class="message-content">
          <div class="message-text">{{ message.content }}</div>
          <div class="message-time">{{ formatTime(message.timestamp) }}</div>
        </div>
      </div>
    </div>
    
    <div class="chat-input">
      <el-input
        v-model="inputMessage"
        placeholder="请输入您的预约需求..."
        @keyup.enter="sendMessage"
        :disabled="isLoading"
      >
        <template #append>
          <el-button @click="sendMessage" :loading="isLoading">
            发送
          </el-button>
        </template>
      </el-input>
    </div>
    
    <VoiceRecorder 
      v-if="isVoiceMode" 
      @voice-result="handleVoiceResult"
      @voice-error="handleVoiceError"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted, nextTick } from 'vue'
import { ElMessage } from 'element-plus'
import { Microphone } from '@element-plus/icons-vue'
import VoiceRecorder from '@/components/VoiceRecorder.vue'
import { chatAPI } from '@/utils/api'

interface Message {
  id: string
  type: 'user' | 'assistant'
  content: string
  timestamp: Date
}

const messages = ref<Message[]>([])
const inputMessage = ref('')
const isLoading = ref(false)
const isVoiceMode = ref(false)
const messagesContainer = ref<HTMLElement>()

// 发送消息
const sendMessage = async () => {
  if (!inputMessage.value.trim() || isLoading.value) return
  
  const userMessage: Message = {
    id: Date.now().toString(),
    type: 'user',
    content: inputMessage.value,
    timestamp: new Date()
  }
  
  messages.value.push(userMessage)
  const messageContent = inputMessage.value
  inputMessage.value = ''
  isLoading.value = true
  
  try {
    const response = await chatAPI.sendMessage({
      message: messageContent,
      conversation_id: getCurrentConversationId()
    })
    
    const assistantMessage: Message = {
      id: (Date.now() + 1).toString(),
      type: 'assistant',
      content: response.data.response,
      timestamp: new Date()
    }
    
    messages.value.push(assistantMessage)
    
    // 如果开启语音模式，播放回复
    if (isVoiceMode.value && response.data.audio_url) {
      playAudio(response.data.audio_url)
    }
    
  } catch (error) {
    ElMessage.error('发送消息失败，请重试')
  } finally {
    isLoading.value = false
    scrollToBottom()
  }
}

// 处理语音识别结果
const handleVoiceResult = (text: string) => {
  inputMessage.value = text
  sendMessage()
}

// 处理语音错误
const handleVoiceError = (error: string) => {
  ElMessage.error(`语音识别失败: ${error}`)
}

// 切换语音模式
const toggleVoice = () => {
  isVoiceMode.value = !isVoiceMode.value
  if (isVoiceMode.value) {
    ElMessage.success('语音模式已开启')
  } else {
    ElMessage.info('语音模式已关闭')
  }
}

// 滚动到底部
const scrollToBottom = () => {
  nextTick(() => {
    if (messagesContainer.value) {
      messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
    }
  })
}

// 格式化时间
const formatTime = (date: Date) => {
  return date.toLocaleTimeString('zh-CN', {
    hour: '2-digit',
    minute: '2-digit'
  })
}

// 获取当前会话ID
const getCurrentConversationId = () => {
  return sessionStorage.getItem('conversation_id') || 'default'
}

// 播放音频
const playAudio = (audioUrl: string) => {
  const audio = new Audio(audioUrl)
  audio.play().catch(error => {
    console.error('音频播放失败:', error)
  })
}

onMounted(() => {
  // 初始化欢迎消息
  messages.value.push({
    id: 'welcome',
    type: 'assistant',
    content: '您好！我是智能预约助手，可以帮您预约会议室。请告诉我您的需求，比如："我需要明天下午2点的会议室"',
    timestamp: new Date()
  })
})
</script>

<style scoped>
.chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.chat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 1px solid #eee;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
  background: #f5f5f5;
  border-radius: 8px;
  margin-bottom: 20px;
}

.message {
  margin-bottom: 15px;
  display: flex;
}

.message.user {
  justify-content: flex-end;
}

.message.assistant {
  justify-content: flex-start;
}

.message-content {
  max-width: 70%;
  padding: 10px 15px;
  border-radius: 18px;
  position: relative;
}

.message.user .message-content {
  background: #409eff;
  color: white;
}

.message.assistant .message-content {
  background: white;
  color: #333;
  border: 1px solid #e4e7ed;
}

.message-text {
  margin-bottom: 5px;
}

.message-time {
  font-size: 12px;
  opacity: 0.7;
}

.chat-input {
  margin-top: auto;
}
</style>
```

### 1.3 语音录制组件 (VoiceRecorder.vue)

```vue
<template>
  <div class="voice-recorder">
    <el-button 
      :type="isRecording ? 'danger' : 'primary'"
      @mousedown="startRecording"
      @mouseup="stopRecording"
      @mouseleave="stopRecording"
      :disabled="!isSupported"
      class="record-button"
    >
      <el-icon><Microphone /></el-icon>
      {{ isRecording ? '松开结束' : '按住说话' }}
    </el-button>
    
    <div v-if="isRecording" class="recording-indicator">
      <div class="wave-animation">
        <div class="wave"></div>
        <div class="wave"></div>
        <div class="wave"></div>
      </div>
      <span>正在录音...</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { ElMessage } from 'element-plus'
import { Microphone } from '@element-plus/icons-vue'

const emit = defineEmits<{
  voiceResult: [text: string]
  voiceError: [error: string]
}>()

const isRecording = ref(false)
const isSupported = ref(false)
const mediaRecorder = ref<MediaRecorder | null>(null)
const audioChunks = ref<Blob[]>([])

// 检查浏览器支持
const checkSupport = () => {
  isSupported.value = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
  if (!isSupported.value) {
    ElMessage.error('您的浏览器不支持语音录制功能')
  }
}

// 开始录音
const startRecording = async () => {
  if (!isSupported.value || isRecording.value) return
  
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
    
    mediaRecorder.value = new MediaRecorder(stream)
    audioChunks.value = []
    
    mediaRecorder.value.ondataavailable = (event) => {
      if (event.data.size > 0) {
        audioChunks.value.push(event.data)
      }
    }
    
    mediaRecorder.value.onstop = async () => {
      const audioBlob = new Blob(audioChunks.value, { type: 'audio/wav' })
      await processAudio(audioBlob)
      
      // 停止所有音频轨道
      stream.getTracks().forEach(track => track.stop())
    }
    
    mediaRecorder.value.start()
    isRecording.value = true
    
  } catch (error) {
    console.error('录音启动失败:', error)
    emit('voiceError', '无法访问麦克风，请检查权限设置')
  }
}

// 停止录音
const stopRecording = () => {
  if (!isRecording.value || !mediaRecorder.value) return
  
  mediaRecorder.value.stop()
  isRecording.value = false
}

// 处理音频数据
const processAudio = async (audioBlob: Blob) => {
  try {
    const formData = new FormData()
    formData.append('audio', audioBlob, 'recording.wav')
    
    const response = await fetch('/api/voice/speech-to-text', {
      method: 'POST',
      body: formData
    })
    
    if (!response.ok) {
      throw new Error('语音识别服务异常')
    }
    
    const result = await response.json()
    
    if (result.success && result.text) {
      emit('voiceResult', result.text)
    } else {
      emit('voiceError', result.error || '语音识别失败')
    }
    
  } catch (error) {
    console.error('语音处理失败:', error)
    emit('voiceError', '语音处理失败，请重试')
  }
}

onMounted(() => {
  checkSupport()
})

onUnmounted(() => {
  if (isRecording.value) {
    stopRecording()
  }
})
</script>

<style scoped>
.voice-recorder {
  text-align: center;
  padding: 20px;
}

.record-button {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  font-size: 16px;
  transition: all 0.3s ease;
}

.record-button:hover {
  transform: scale(1.05);
}

.record-button:active {
  transform: scale(0.95);
}

.recording-indicator {
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.wave-animation {
  display: flex;
  gap: 3px;
}

.wave {
  width: 4px;
  height: 20px;
  background: #409eff;
  border-radius: 2px;
  animation: wave 1.2s ease-in-out infinite;
}

.wave:nth-child(2) {
  animation-delay: 0.1s;
}

.wave:nth-child(3) {
  animation-delay: 0.2s;
}

@keyframes wave {
  0%, 40%, 100% {
    transform: scaleY(0.4);
  }
  20% {
    transform: scaleY(1);
  }
}
</style>
```

## 2. 后端核心代码

### 2.1 应用主入口 (main.py)

```python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
import uvicorn

from app.core.config import settings
from app.core.database import engine, Base
from app.api import auth, chat, rooms, reservations, notifications, reports, voice
from app.core.security import get_current_user

# 创建数据库表
@asynccontextmanager
async def lifespan(app: FastAPI):
    # 启动时创建表
    Base.metadata.create_all(bind=engine)
    yield
    # 关闭时清理资源

app = FastAPI(
    title="智能预约系统 API",
    description="基于AI技术的智能会议室预约管理系统",
    version="1.0.0",
    lifespan=lifespan
)

# CORS中间件配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境应限制具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 静态文件服务
app.mount("/static", StaticFiles(directory="static"), name="static")

# API路由注册
app.include_router(auth.router, prefix="/api/auth", tags=["认证"])
app.include_router(chat.router, prefix="/api/chat", tags=["智能对话"])
app.include_router(rooms.router, prefix="/api/rooms", tags=["会议室管理"])
app.include_router(reservations.router, prefix="/api/reservations", tags=["预约管理"])
app.include_router(notifications.router, prefix="/api/notifications", tags=["通知管理"])
app.include_router(reports.router, prefix="/api/reports", tags=["数据报表"])
app.include_router(voice.router, prefix="/api/voice", tags=["语音处理"])

@app.get("/")
async def root():
    return {
        "message": "智能预约系统 API",
        "version": "1.0.0",
        "status": "running"
    }

@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level="info"
    )
```

### 2.2 智能对话服务 (ai_service.py)

```python
import asyncio
import json
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import openai
from sqlalchemy.orm import Session

from app.core.config import settings
from app.models.chat import ChatMessage, Conversation
from app.models.reservation import Reservation
from app.models.room import Room
from app.services.reservation_service import ReservationService
from app.utils.date_utils import parse_natural_time, format_datetime

class AIService:
    def __init__(self):
        self.openai_client = openai.AsyncOpenAI(
            api_key=settings.OPENAI_API_KEY,
            base_url=settings.OPENAI_BASE_URL
        )
        self.reservation_service = ReservationService()
        
        # 系统提示词
        self.system_prompt = """
        你是一个智能会议室预约助手，专门帮助用户预约会议室。
        
        你的主要功能：
        1. 理解用户的预约需求（时间、人数、设备要求等）
        2. 查询可用的会议室
        3. 帮助用户完成预约
        4. 处理预约变更和取消
        5. 回答关于会议室的问题
        
        交互原则：
        - 友好、专业、高效
        - 主动询问缺失的关键信息
        - 提供清晰的选择和建议
        - 确认重要操作
        
        当前时间：{current_time}
        """
    
    async def process_message(
        self, 
        message: str, 
        conversation_id: str,
        user_id: int,
        db: Session
    ) -> Dict[str, Any]:
        """
        处理用户消息并生成智能回复
        """
        try:
            # 获取或创建会话
            conversation = self._get_or_create_conversation(
                conversation_id, user_id, db
            )
            
            # 保存用户消息
            user_message = ChatMessage(
                conversation_id=conversation.id,
                role="user",
                content=message,
                timestamp=datetime.now()
            )
            db.add(user_message)
            
            # 获取会话历史
            chat_history = self._get_chat_history(conversation.id, db)
            
            # 意图识别和实体提取
            intent_result = await self._analyze_intent(message, chat_history)
            
            # 根据意图处理请求
            response_data = await self._handle_intent(
                intent_result, message, user_id, db
            )
            
            # 生成AI回复
            ai_response = await self._generate_response(
                message, chat_history, response_data
            )
            
            # 保存AI回复
            assistant_message = ChatMessage(
                conversation_id=conversation.id,
                role="assistant",
                content=ai_response,
                timestamp=datetime.now(),
                metadata=json.dumps(response_data)
            )
            db.add(assistant_message)
            db.commit()
            
            return {
                "response": ai_response,
                "intent": intent_result["intent"],
                "entities": intent_result["entities"],
                "actions": response_data.get("actions", []),
                "suggestions": response_data.get("suggestions", [])
            }
            
        except Exception as e:
            db.rollback()
            raise HTTPException(status_code=500, detail=f"AI处理失败: {str(e)}")
    
    async def _analyze_intent(self, message: str, history: List[Dict]) -> Dict:
        """
        分析用户意图和提取实体信息
        """
        prompt = f"""
        分析以下用户消息的意图和实体信息：
        
        用户消息：{message}
        
        请返回JSON格式的结果，包含：
        {{
            "intent": "预约意图类型",
            "entities": {{
                "time": "时间信息",
                "duration": "持续时间",
                "participants": "参会人数",
                "equipment": "设备需求",
                "location": "地点偏好"
            }},
            "confidence": "置信度(0-1)"
        }}
        
        支持的意图类型：
        - create_reservation: 创建预约
        - query_availability: 查询可用性
        - modify_reservation: 修改预约
        - cancel_reservation: 取消预约
        - general_inquiry: 一般咨询
        """
        
        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "你是一个专业的意图识别助手。"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1
            )
            
            result = json.loads(response.choices[0].message.content)
            return result
            
        except Exception as e:
            # 降级处理：使用规则匹配
            return self._fallback_intent_analysis(message)
    
    def _fallback_intent_analysis(self, message: str) -> Dict:
        """
        降级意图分析：基于关键词匹配
        """
        message_lower = message.lower()
        
        # 预约关键词
        if any(word in message_lower for word in ['预约', '预定', '订', '要', '需要']):
            intent = "create_reservation"
        # 查询关键词
        elif any(word in message_lower for word in ['查询', '查看', '有没有', '可用']):
            intent = "query_availability"
        # 修改关键词
        elif any(word in message_lower for word in ['修改', '更改', '调整']):
            intent = "modify_reservation"
        # 取消关键词
        elif any(word in message_lower for word in ['取消', '删除']):
            intent = "cancel_reservation"
        else:
            intent = "general_inquiry"
        
        # 简单实体提取
        entities = self._extract_entities_simple(message)
        
        return {
            "intent": intent,
            "entities": entities,
            "confidence": 0.7
        }
    
    def _extract_entities_simple(self, message: str) -> Dict:
        """
        简单实体提取
        """
        entities = {}
        
        # 提取时间信息
        time_info = parse_natural_time(message)
        if time_info:
            entities["time"] = time_info
        
        # 提取人数信息
        import re
        participants_match = re.search(r'(\d+)\s*[人个]', message)
        if participants_match:
            entities["participants"] = int(participants_match.group(1))
        
        # 提取设备需求
        equipment_keywords = ['投影仪', '投影', '电脑', '音响', '话筒', '麦克风', '视频会议']
        equipment = [kw for kw in equipment_keywords if kw in message]
        if equipment:
            entities["equipment"] = equipment
        
        return entities
    
    async def _handle_intent(
        self, 
        intent_result: Dict, 
        message: str, 
        user_id: int, 
        db: Session
    ) -> Dict:
        """
        根据意图处理具体业务逻辑
        """
        intent = intent_result["intent"]
        entities = intent_result["entities"]
        
        if intent == "create_reservation":
            return await self._handle_create_reservation(entities, user_id, db)
        elif intent == "query_availability":
            return await self._handle_query_availability(entities, db)
        elif intent == "modify_reservation":
            return await self._handle_modify_reservation(entities, user_id, db)
        elif intent == "cancel_reservation":
            return await self._handle_cancel_reservation(entities, user_id, db)
        else:
            return await self._handle_general_inquiry(message, db)
    
    async def _handle_create_reservation(
        self, entities: Dict, user_id: int, db: Session
    ) -> Dict:
        """
        处理创建预约请求
        """
        # 检查必要信息
        missing_info = []
        if "time" not in entities:
            missing_info.append("时间")
        if "participants" not in entities:
            missing_info.append("参会人数")
        
        if missing_info:
            return {
                "type": "missing_info",
                "missing": missing_info,
                "message": f"请提供以下信息：{', '.join(missing_info)}"
            }
        
        # 查询可用会议室
        available_rooms = await self.reservation_service.find_available_rooms(
            start_time=entities["time"]["start"],
            end_time=entities["time"]["end"],
            min_capacity=entities["participants"],
            equipment_requirements=entities.get("equipment", []),
            db=db
        )
        
        if not available_rooms:
            return {
                "type": "no_availability",
                "message": "抱歉，指定时间没有合适的会议室可用。",
                "suggestions": await self._get_alternative_suggestions(
                    entities, db
                )
            }
        
        return {
            "type": "room_options",
            "rooms": available_rooms,
            "message": f"为您找到 {len(available_rooms)} 个可用会议室：",
            "actions": ["confirm_reservation"]
        }
    
    async def _generate_response(
        self, 
        user_message: str, 
        chat_history: List[Dict], 
        response_data: Dict
    ) -> str:
        """
        生成自然语言回复
        """
        # 构建上下文
        context = {
            "user_message": user_message,
            "response_data": response_data,
            "chat_history": chat_history[-5:]  # 最近5条消息
        }
        
        prompt = f"""
        基于以下信息生成自然、友好的回复：
        
        用户消息：{user_message}
        处理结果：{json.dumps(response_data, ensure_ascii=False, indent=2)}
        
        要求：
        1. 回复要自然、友好、专业
        2. 如果有会议室选项，要清晰列出
        3. 如果需要更多信息，要明确指出
        4. 如果有建议，要积极提供
        5. 保持简洁，避免冗长
        """
        
        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {
                        "role": "system", 
                        "content": self.system_prompt.format(
                            current_time=datetime.now().strftime("%Y-%m-%d %H:%M")
                        )
                    },
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=500
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            # 降级处理：生成模板回复
            return self._generate_template_response(response_data)
    
    def _generate_template_response(self, response_data: Dict) -> str:
        """
        生成模板回复（降级处理）
        """
        response_type = response_data.get("type", "general")
        
        if response_type == "missing_info":
            missing = response_data.get("missing", [])
            return f"请提供以下信息以便为您预约：{', '.join(missing)}"
        
        elif response_type == "room_options":
            rooms = response_data.get("rooms", [])
            if rooms:
                room_list = "\n".join([
                    f"{i+1}. {room['name']} (容纳{room['capacity']}人)"
                    for i, room in enumerate(rooms[:3])
                ])
                return f"为您找到以下可用会议室：\n{room_list}\n\n请选择您需要的会议室。"
        
        elif response_type == "no_availability":
            return "抱歉，指定时间没有合适的会议室。请尝试其他时间或联系管理员。"
        
        return "我已收到您的请求，正在为您处理..."
    
    def _get_or_create_conversation(
        self, conversation_id: str, user_id: int, db: Session
    ) -> Conversation:
        """
        获取或创建会话
        """
        conversation = db.query(Conversation).filter(
            Conversation.id == conversation_id
        ).first()
        
        if not conversation:
            conversation = Conversation(
                id=conversation_id,
                user_id=user_id,
                created_at=datetime.now(),
                updated_at=datetime.now()
            )
            db.add(conversation)
            db.commit()
        
        return conversation
    
    def _get_chat_history(
        self, conversation_id: str, db: Session, limit: int = 10
    ) -> List[Dict]:
        """
        获取聊天历史
        """
        messages = db.query(ChatMessage).filter(
            ChatMessage.conversation_id == conversation_id
        ).order_by(ChatMessage.timestamp.desc()).limit(limit).all()
        
        return [
            {
                "role": msg.role,
                "content": msg.content,
                "timestamp": msg.timestamp.isoformat()
            }
            for msg in reversed(messages)
        ]
```

### 2.3 预约管理服务 (reservation_service.py)

```python
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func

from app.models.reservation import Reservation, ReservationStatus
from app.models.room import Room
from app.models.user import User
from app.utils.date_utils import is_time_conflict, get_business_hours

class ReservationService:
    """
    预约管理服务类
    处理会议室预约的核心业务逻辑
    """
    
    def __init__(self):
        self.max_advance_days = 30  # 最多提前30天预约
        self.max_duration_hours = 8  # 单次预约最长8小时
        self.min_duration_minutes = 30  # 单次预约最短30分钟
    
    async def create_reservation(
        self,
        user_id: int,
        room_id: int,
        start_time: datetime,
        end_time: datetime,
        title: str,
        description: Optional[str] = None,
        participants: Optional[int] = None,
        db: Session = None
    ) -> Dict[str, Any]:
        """
        创建新的预约
        """
        # 验证预约参数
        validation_result = self._validate_reservation_params(
            user_id, room_id, start_time, end_time, participants, db
        )
        
        if not validation_result["valid"]:
            return {
                "success": False,
                "error": validation_result["error"],
                "code": validation_result["code"]
            }
        
        # 检查时间冲突
        conflicts = await self._check_time_conflicts(
            room_id, start_time, end_time, db
        )
        
        if conflicts:
            return {
                "success": False,
                "error": "预约时间与现有预约冲突",
                "code": "TIME_CONFLICT",
                "conflicts": conflicts,
                "suggestions": await self._generate_alternative_times(
                    room_id, start_time, end_time, db
                )
            }
        
        # 创建预约记录
        try:
            reservation = Reservation(
                user_id=user_id,
                room_id=room_id,
                title=title,
                description=description,
                start_time=start_time,
                end_time=end_time,
                participants=participants,
                status=ReservationStatus.CONFIRMED,
                created_at=datetime.now(),
                updated_at=datetime.now()
            )
            
            db.add(reservation)
            db.commit()
            db.refresh(reservation)
            
            # 发送通知
            await self._send_reservation_notification(
                reservation, "created", db
            )
            
            return {
                "success": True,
                "reservation": self._format_reservation(reservation),
                "message": "预约创建成功"
            }
            
        except Exception as e:
            db.rollback()
            return {
                "success": False,
                "error": f"创建预约失败: {str(e)}",
                "code": "CREATE_FAILED"
            }
    
    async def find_available_rooms(
        self,
        start_time: datetime,
        end_time: datetime,
        min_capacity: Optional[int] = None,
        equipment_requirements: Optional[List[str]] = None,
        location_preference: Optional[str] = None,
        db: Session = None
    ) -> List[Dict[str, Any]]:
        """
        查找可用的会议室
        """
        # 基础查询：获取所有活跃的会议室
        query = db.query(Room).filter(Room.is_active == True)
        
        # 容量过滤
        if min_capacity:
            query = query.filter(Room.capacity >= min_capacity)
        
        # 设备需求过滤
        if equipment_requirements:
            for equipment in equipment_requirements:
                query = query.filter(
                    Room.equipment.contains(equipment)
                )
        
        # 地点偏好过滤
        if location_preference:
            query = query.filter(
                or_(
                    Room.building.ilike(f"%{location_preference}%"),
                    Room.floor.ilike(f"%{location_preference}%")
                )
            )
        
        all_rooms = query.all()
        available_rooms = []
        
        # 检查每个会议室的可用性
        for room in all_rooms:
            conflicts = await self._check_time_conflicts(
                room.id, start_time, end_time, db
            )
            
            if not conflicts:
                # 计算推荐分数
                score = self._calculate_room_score(
                    room, min_capacity, equipment_requirements
                )
                
                available_rooms.append({
                    "id": room.id,
                    "name": room.name,
                    "capacity": room.capacity,
                    "equipment": room.equipment,
                    "location": f"{room.building} {room.floor}",
                    "description": room.description,
                    "score": score,
                    "image_url": room.image_url
                })
        
        # 按推荐分数排序
        available_rooms.sort(key=lambda x: x["score"], reverse=True)
        
        return available_rooms
    
    async def _check_time_conflicts(
        self,
        room_id: int,
        start_time: datetime,
        end_time: datetime,
        db: Session,
        exclude_reservation_id: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        检查时间冲突
        """
        query = db.query(Reservation).filter(
            and_(
                Reservation.room_id == room_id,
                Reservation.status.in_([
                    ReservationStatus.CONFIRMED,
                    ReservationStatus.PENDING
                ]),
                or_(
                    # 新预约开始时间在现有预约期间
                    and_(
                        Reservation.start_time <= start_time,
                        Reservation.end_time > start_time
                    ),
                    # 新预约结束时间在现有预约期间
                    and_(
                        Reservation.start_time < end_time,
                        Reservation.end_time >= end_time
                    ),
                    # 新预约完全包含现有预约
                    and_(
                        Reservation.start_time >= start_time,
                        Reservation.end_time <= end_time
                    )
                )
            )
        )
        
        if exclude_reservation_id:
            query = query.filter(
                Reservation.id != exclude_reservation_id
            )
        
        conflicts = query.all()
        
        return [
            {
                "id": conflict.id,
                "title": conflict.title,
                "start_time": conflict.start_time.isoformat(),
                "end_time": conflict.end_time.isoformat(),
                "user_name": conflict.user.name if conflict.user else "未知用户"
            }
            for conflict in conflicts
        ]
    
    def _validate_reservation_params(
        self,
        user_id: int,
        room_id: int,
        start_time: datetime,
        end_time: datetime,
        participants: Optional[int],
        db: Session
    ) -> Dict[str, Any]:
        """
        验证预约参数
        """
        # 检查用户是否存在
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            return {
                "valid": False,
                "error": "用户不存在",
                "code": "USER_NOT_FOUND"
            }
        
        # 检查会议室是否存在且可用
        room = db.query(Room).filter(
            and_(Room.id == room_id, Room.is_active == True)
        ).first()
        if not room:
            return {
                "valid": False,
                "error": "会议室不存在或不可用",
                "code": "ROOM_NOT_AVAILABLE"
            }
        
        # 检查时间参数
        if start_time >= end_time:
            return {
                "valid": False,
                "error": "结束时间必须晚于开始时间",
                "code": "INVALID_TIME_RANGE"
            }
        
        # 检查预约时长
        duration = end_time - start_time
        if duration.total_seconds() < self.min_duration_minutes * 60:
            return {
                "valid": False,
                "error": f"预约时长不能少于{self.min_duration_minutes}分钟",
                "code": "DURATION_TOO_SHORT"
            }
        
        if duration.total_seconds() > self.max_duration_hours * 3600:
            return {
                "valid": False,
                "error": f"预约时长不能超过{self.max_duration_hours}小时",
                "code": "DURATION_TOO_LONG"
            }
        
        # 检查提前预约时间
        now = datetime.now()
        if start_time <= now:
            return {
                "valid": False,
                "error": "不能预约过去的时间",
                "code": "PAST_TIME"
            }
        
        advance_days = (start_time.date() - now.date()).days
        if advance_days > self.max_advance_days:
            return {
                "valid": False,
                "error": f"不能提前超过{self.max_advance_days}天预约",
                "code": "TOO_ADVANCE"
            }
        
        # 检查营业时间
        business_hours = get_business_hours(start_time.date())
        if not self._is_within_business_hours(start_time, end_time, business_hours):
            return {
                "valid": False,
                "error": "预约时间必须在营业时间内",
                "code": "OUTSIDE_BUSINESS_HOURS"
            }
        
        # 检查人数限制
        if participants and participants > room.capacity:
            return {
                "valid": False,
                "error": f"参会人数({participants})超过会议室容量({room.capacity})",
                "code": "CAPACITY_EXCEEDED"
            }
        
        return {"valid": True}
    
    def _calculate_room_score(
        self,
        room: Room,
        min_capacity: Optional[int],
        equipment_requirements: Optional[List[str]]
    ) -> float:
        """
        计算会议室推荐分数
        """
        score = 0.0
        
        # 容量匹配度 (40%权重)
        if min_capacity:
            if room.capacity >= min_capacity:
                # 容量刚好合适得分最高
                capacity_ratio = min_capacity / room.capacity
                if capacity_ratio >= 0.8:
                    score += 40
                elif capacity_ratio >= 0.6:
                    score += 35
                elif capacity_ratio >= 0.4:
                    score += 30
                else:
                    score += 20
        else:
            score += 30  # 没有容量要求时给基础分
        
        # 设备匹配度 (30%权重)
        if equipment_requirements:
            matched_equipment = 0
            for equipment in equipment_requirements:
                if equipment in room.equipment:
                    matched_equipment += 1
            
            equipment_score = (matched_equipment / len(equipment_requirements)) * 30
            score += equipment_score
        else:
            score += 20  # 没有设备要求时给基础分
        
        # 会议室等级 (20%权重)
        level_scores = {
            "premium": 20,
            "standard": 15,
            "basic": 10
        }
        score += level_scores.get(room.level, 10)
        
        # 使用频率 (10%权重) - 使用频率低的会议室得分更高
        # 这里简化处理，实际应该查询历史使用数据
        score += 10
        
        return score
    
    async def _generate_alternative_times(
        self,
        room_id: int,
        preferred_start: datetime,
        preferred_end: datetime,
        db: Session
    ) -> List[Dict[str, Any]]:
        """
        生成替代时间建议
        """
        duration = preferred_end - preferred_start
        alternatives = []
        
        # 在同一天寻找其他时间段
        date = preferred_start.date()
        business_hours = get_business_hours(date)
        
        # 生成可能的时间段（每30分钟一个）
        current_time = datetime.combine(date, business_hours["start"])
        end_of_day = datetime.combine(date, business_hours["end"])
        
        while current_time + duration <= end_of_day:
            test_end = current_time + duration
            
            # 检查这个时间段是否可用
            conflicts = await self._check_time_conflicts(
                room_id, current_time, test_end, db
            )
            
            if not conflicts:
                alternatives.append({
                    "start_time": current_time.isoformat(),
                    "end_time": test_end.isoformat(),
                    "date": date.isoformat()
                })
            
            current_time += timedelta(minutes=30)
            
            # 最多返回5个建议
            if len(alternatives) >= 5:
                break
        
        return alternatives
    
    def _is_within_business_hours(
        self,
        start_time: datetime,
        end_time: datetime,
        business_hours: Dict[str, Any]
    ) -> bool:
        """
        检查是否在营业时间内
        """
        start_time_only = start_time.time()
        end_time_only = end_time.time()
        
        return (
            start_time_only >= business_hours["start"] and
            end_time_only <= business_hours["end"]
        )
    
    async def _send_reservation_notification(
        self,
        reservation: Reservation,
        action: str,
        db: Session
    ):
        """
        发送预约通知
        """
        # 这里应该集成通知服务
        # 暂时只记录日志
        print(f"通知: 预约 {reservation.id} 已{action}")
    
    def _format_reservation(self, reservation: Reservation) -> Dict[str, Any]:
        """
        格式化预约信息
        """
        return {
            "id": reservation.id,
            "title": reservation.title,
            "description": reservation.description,
            "start_time": reservation.start_time.isoformat(),
            "end_time": reservation.end_time.isoformat(),
            "participants": reservation.participants,
            "status": reservation.status.value,
            "room": {
                "id": reservation.room.id,
                "name": reservation.room.name,
                "location": f"{reservation.room.building} {reservation.room.floor}"
            } if reservation.room else None,
            "user": {
                "id": reservation.user.id,
                "name": reservation.user.name
            } if reservation.user else None,
            "created_at": reservation.created_at.isoformat(),
            "updated_at": reservation.updated_at.isoformat()
        }
```

## 3. 数据模型定义

### 3.1 用户模型 (user.py)

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.orm import relationship
from datetime import datetime

from app.core.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    name = Column(String(100), nullable=False)
    hashed_password = Column(String(255), nullable=False)
    department = Column(String(100))
    position = Column(String(100))
    phone = Column(String(20))
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)
    avatar_url = Column(String(255))
    preferences = Column(Text)  # JSON格式的用户偏好设置
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    last_login = Column(DateTime)
    
    # 关系定义
    reservations = relationship("Reservation", back_populates="user")
    chat_conversations = relationship("Conversation", back_populates="user")
    notifications = relationship("Notification", back_populates="user")
    
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}', name='{self.name}')>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "name": self.name,
            "department": self.department,
            "position": self.position,
            "phone": self.phone,
            "is_active": self.is_active,
            "is_admin": self.is_admin,
            "avatar_url": self.avatar_url,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "last_login": self.last_login.isoformat() if self.last_login else None
        }
```

### 3.2 会议室模型 (room.py)

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, JSON
from sqlalchemy.orm import relationship
from datetime import datetime

from app.core.database import Base

class Room(Base):
    __tablename__ = "rooms"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, index=True)
    building = Column(String(50), nullable=False)
    floor = Column(String(20), nullable=False)
    room_number = Column(String(20), nullable=False)
    capacity = Column(Integer, nullable=False)
    description = Column(Text)
    equipment = Column(JSON)  # 设备列表，如 ["投影仪", "音响", "视频会议"]
    features = Column(JSON)   # 特色功能，如 ["自然采光", "隔音", "无线投屏"]
    level = Column(String(20), default="standard")  # premium, standard, basic
    hourly_rate = Column(Integer, default=0)  # 每小时费用（分）
    image_url = Column(String(255))
    floor_plan_url = Column(String(255))
    is_active = Column(Boolean, default=True)
    booking_rules = Column(JSON)  # 预约规则配置
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    
    # 关系定义
    reservations = relationship("Reservation", back_populates="room")
    
    def __repr__(self):
        return f"<Room(id={self.id}, name='{self.name}', capacity={self.capacity})>"
    
    @property
    def location(self):
        return f"{self.building} {self.floor} {self.room_number}"
    
    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "building": self.building,
            "floor": self.floor,
            "room_number": self.room_number,
            "location": self.location,
            "capacity": self.capacity,
            "description": self.description,
            "equipment": self.equipment or [],
            "features": self.features or [],
            "level": self.level,
            "hourly_rate": self.hourly_rate,
            "image_url": self.image_url,
            "floor_plan_url": self.floor_plan_url,
            "is_active": self.is_active,
            "booking_rules": self.booking_rules or {},
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
```

### 3.3 预约模型 (reservation.py)

```python
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, Enum as SQLEnum
from sqlalchemy.orm import relationship
from datetime import datetime
from enum import Enum

from app.core.database import Base

class ReservationStatus(Enum):
    PENDING = "pending"        # 待确认
    CONFIRMED = "confirmed"    # 已确认
    CANCELLED = "cancelled"    # 已取消
    COMPLETED = "completed"    # 已完成
    NO_SHOW = "no_show"       # 未出席

class Reservation(Base):
    __tablename__ = "reservations"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    room_id = Column(Integer, ForeignKey("rooms.id"), nullable=False)
    title = Column(String(200), nullable=False)
    description = Column(Text)
    start_time = Column(DateTime, nullable=False, index=True)
    end_time = Column(DateTime, nullable=False, index=True)
    participants = Column(Integer)
    status = Column(SQLEnum(ReservationStatus), default=ReservationStatus.CONFIRMED)
    booking_code = Column(String(20), unique=True, index=True)  # 预约码
    notes = Column(Text)  # 备注信息
    cost = Column(Integer, default=0)  # 费用（分）
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    cancelled_at = Column(DateTime)
    cancellation_reason = Column(Text)
    
    # 关系定义
    user = relationship("User", back_populates="reservations")
    room = relationship("Room", back_populates="reservations")
    
    def __repr__(self):
        return f"<Reservation(id={self.id}, title='{self.title}', status='{self.status.value}')>"
    
    @property
    def duration_minutes(self):
        """预约时长（分钟）"""
        if self.start_time and self.end_time:
            return int((self.end_time - self.start_time).total_seconds() / 60)
        return 0
    
    @property
    def is_active(self):
        """是否为活跃预约"""
        return self.status in [ReservationStatus.PENDING, ReservationStatus.CONFIRMED]
    
    def to_dict(self):
        return {
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "start_time": self.start_time.isoformat() if self.start_time else None,
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "participants": self.participants,
            "status": self.status.value,
            "booking_code": self.booking_code,
            "notes": self.notes,
            "cost": self.cost,
            "duration_minutes": self.duration_minutes,
            "room": self.room.to_dict() if self.room else None,
            "user": self.user.to_dict() if self.user else None,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
```

## 4. API接口实现

### 4.1 智能对话API (chat.py)

```python
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from sqlalchemy.orm import Session
from typing import Dict, Any
from pydantic import BaseModel

from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.services.ai_service import AIService
from app.services.voice_service import VoiceService

router = APIRouter()
ai_service = AIService()
voice_service = VoiceService()

class ChatRequest(BaseModel):
    message: str
    conversation_id: str = "default"
    voice_enabled: bool = False

class ChatResponse(BaseModel):
    response: str
    intent: str
    entities: Dict[str, Any]
    actions: list
    suggestions: list
    audio_url: str = None

@router.post("/send", response_model=ChatResponse)
async def send_message(
    request: ChatRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    发送聊天消息并获取AI回复
    """
    try:
        # 处理文本消息
        result = await ai_service.process_message(
            message=request.message,
            conversation_id=request.conversation_id,
            user_id=current_user.id,
            db=db
        )
        
        # 如果启用语音，生成语音回复
        audio_url = None
        if request.voice_enabled:
            audio_url = await voice_service.text_to_speech(
                text=result["response"],
                user_id=current_user.id
            )
        
        return ChatResponse(
            response=result["response"],
            intent=result["intent"],
            entities=result["entities"],
            actions=result["actions"],
            suggestions=result["suggestions"],
            audio_url=audio_url
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/conversations/{conversation_id}/history")
async def get_conversation_history(
    conversation_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    获取对话历史记录
    """
    try:
        history = ai_service._get_chat_history(conversation_id, db, limit=50)
        return {"history": history}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### 4.2 语音处理API (voice.py)

```python
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from sqlalchemy.orm import Session
from typing import Dict, Any
import tempfile
import os

from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.services.voice_service import VoiceService

router = APIRouter()
voice_service = VoiceService()

@router.post("/speech-to-text")
async def speech_to_text(
    audio: UploadFile = File(...),
    current_user: User = Depends(get_current_user)
):
    """
    语音转文字
    """
    if not audio.content_type.startswith('audio/'):
        raise HTTPException(status_code=400, detail="文件必须是音频格式")
    
    try:
        # 保存临时文件
        with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as temp_file:
            content = await audio.read()
            temp_file.write(content)
            temp_file_path = temp_file.name
        
        # 语音识别
        result = await voice_service.speech_to_text(
            audio_file_path=temp_file_path,
            user_id=current_user.id
        )
        
        # 清理临时文件
        os.unlink(temp_file_path)
        
        return {
            "success": True,
            "text": result["text"],
            "confidence": result.get("confidence", 0.0),
            "language": result.get("language", "zh-CN")
        }
        
    except Exception as e:
        # 确保清理临时文件
        if 'temp_file_path' in locals():
            try:
                os.unlink(temp_file_path)
            except:
                pass
        
        raise HTTPException(status_code=500, detail=f"语音识别失败: {str(e)}")

@router.post("/text-to-speech")
async def text_to_speech(
    text: str,
    voice: str = "default",
    speed: float = 1.0,
    current_user: User = Depends(get_current_user)
):
    """
    文字转语音
    """
    if not text or len(text.strip()) == 0:
        raise HTTPException(status_code=400, detail="文本内容不能为空")
    
    if len(text) > 1000:
        raise HTTPException(status_code=400, detail="文本长度不能超过1000字符")
    
    try:
        result = await voice_service.text_to_speech(
            text=text,
            voice=voice,
            speed=speed,
            user_id=current_user.id
        )
        
        return {
            "success": True,
            "audio_url": result,
            "text": text,
            "voice": voice,
            "speed": speed
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"语音合成失败: {str(e)}")
```

## 5. 工具函数

### 5.1 日期时间工具 (date_utils.py)

```python
import re
from datetime import datetime, timedelta, time
from typing import Dict, Optional, Tuple, Any
import jieba

def parse_natural_time(text: str) -> Optional[Dict[str, datetime]]:
    """
    解析自然语言时间表达
    """
    now = datetime.now()
    text = text.lower().strip()
    
    # 时间模式匹配
    patterns = [
        # 明天下午2点到4点
        (r'明天.*?(\d{1,2})点.*?到.*?(\d{1,2})点', _parse_tomorrow_time),
        # 今天下午2点到4点  
        (r'今天.*?(\d{1,2})点.*?到.*?(\d{1,2})点', _parse_today_time),
        # 下周一上午9点到11点
        (r'下周(一|二|三|四|五|六|日).*?(\d{1,2})点.*?到.*?(\d{1,2})点', _parse_next_week_time),
        # 2024-01-15 14:00-16:00
        (r'(\d{4})-(\d{1,2})-(\d{1,2})\s+(\d{1,2}):(\d{2})-(\d{1,2}):(\d{2})', _parse_iso_time),
        # 1月15日下午2点到4点
        (r'(\d{1,2})月(\d{1,2})日.*?(\d{1,2})点.*?到.*?(\d{1,2})点', _parse_date_time)
    ]
    
    for pattern, parser in patterns:
        match = re.search(pattern, text)
        if match:
            try:
                return parser(match, now)
            except:
                continue
    
    return None

def _parse_tomorrow_time(match, now: datetime) -> Dict[str, datetime]:
    """解析明天的时间"""
    start_hour = int(match.group(1))
    end_hour = int(match.group(2))
    
    # 处理上午下午
    if '下午' in match.group(0) or '晚上' in match.group(0):
        if start_hour < 12:
            start_hour += 12
        if end_hour < 12:
            end_hour += 12
    
    tomorrow = now + timedelta(days=1)
    start_time = datetime.combine(tomorrow.date(), time(start_hour, 0))
    end_time = datetime.combine(tomorrow.date(), time(end_hour, 0))
    
    return {"start": start_time, "end": end_time}

def _parse_today_time(match, now: datetime) -> Dict[str, datetime]:
    """解析今天的时间"""
    start_hour = int(match.group(1))
    end_hour = int(match.group(2))
    
    # 处理上午下午
    if '下午' in match.group(0) or '晚上' in match.group(0):
        if start_hour < 12:
            start_hour += 12
        if end_hour < 12:
            end_hour += 12
    
    start_time = datetime.combine(now.date(), time(start_hour, 0))
    end_time = datetime.combine(now.date(), time(end_hour, 0))
    
    return {"start": start_time, "end": end_time}

def get_business_hours(date) -> Dict[str, time]:
    """
    获取营业时间
    """
    # 工作日: 8:00-22:00
    # 周末: 9:00-21:00
    weekday = date.weekday()
    
    if weekday < 5:  # 周一到周五
        return {
            "start": time(8, 0),
            "end": time(22, 0)
        }
    else:  # 周末
        return {
            "start": time(9, 0),
            "end": time(21, 0)
        }

def format_datetime(dt: datetime, format_type: str = "default") -> str:
    """
    格式化日期时间
    """
    if format_type == "date_only":
        return dt.strftime("%Y年%m月%d日")
    elif format_type == "time_only":
        return dt.strftime("%H:%M")
    elif format_type == "datetime_cn":
        return dt.strftime("%Y年%m月%d日 %H:%M")
    else:
        return dt.strftime("%Y-%m-%d %H:%M:%S")
```

### 5.2 智能推荐算法 (recommendation.py)

```python
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from app.models.reservation import Reservation
from app.models.room import Room
from app.models.user import User

class RecommendationEngine:
    """
    智能推荐引擎
    """
    
    def __init__(self, db: Session):
        self.db = db
    
    def recommend_rooms(self, 
                       user_id: int,
                       start_time: datetime,
                       end_time: datetime,
                       participants: int = 1,
                       preferences: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """
        推荐合适的会议室
        """
        # 获取可用会议室
        available_rooms = self._get_available_rooms(start_time, end_time)
        
        # 获取用户历史偏好
        user_preferences = self._get_user_preferences(user_id)
        
        # 计算推荐分数
        recommendations = []
        for room in available_rooms:
            score = self._calculate_room_score(
                room, participants, user_preferences, preferences
            )
            
            recommendations.append({
                "room": room.to_dict(),
                "score": score,
                "reasons": self._get_recommendation_reasons(
                    room, participants, user_preferences
                )
            })
        
        # 按分数排序
        recommendations.sort(key=lambda x: x["score"], reverse=True)
        
        return recommendations[:5]  # 返回前5个推荐
    
    def _get_available_rooms(self, start_time: datetime, end_time: datetime) -> List[Room]:
        """
        获取指定时间段内可用的会议室
        """
        # 查询在指定时间段内没有预约的会议室
        occupied_room_ids = self.db.query(Reservation.room_id).filter(
            Reservation.start_time < end_time,
            Reservation.end_time > start_time,
            Reservation.status.in_(['confirmed', 'pending'])
        ).subquery()
        
        available_rooms = self.db.query(Room).filter(
            ~Room.id.in_(occupied_room_ids),
            Room.is_active == True
        ).all()
        
        return available_rooms
    
    def _calculate_room_score(self, 
                             room: Room, 
                             participants: int,
                             user_preferences: Dict[str, Any],
                             preferences: Dict[str, Any] = None) -> float:
        """
        计算会议室推荐分数
        """
        score = 0.0
        
        # 容量匹配度 (30%)
        capacity_score = self._calculate_capacity_score(room.capacity, participants)
        score += capacity_score * 0.3
        
        # 设备匹配度 (25%)
        equipment_score = self._calculate_equipment_score(room, preferences)
        score += equipment_score * 0.25
        
        # 用户历史偏好 (20%)
        preference_score = self._calculate_preference_score(room, user_preferences)
        score += preference_score * 0.2
        
        # 位置便利性 (15%)
        location_score = self._calculate_location_score(room)
        score += location_score * 0.15
        
        # 价格因素 (10%)
        price_score = self._calculate_price_score(room.hourly_rate)
        score += price_score * 0.1
        
        return min(score, 1.0)  # 确保分数不超过1
    
    def _calculate_capacity_score(self, room_capacity: int, participants: int) -> float:
        """
        计算容量匹配分数
        """
        if room_capacity < participants:
            return 0.0  # 容量不足
        
        # 理想情况：会议室容量是参与人数的1.2-1.5倍
        ideal_min = participants * 1.2
        ideal_max = participants * 1.5
        
        if ideal_min <= room_capacity <= ideal_max:
            return 1.0
        elif room_capacity < ideal_min:
            return 0.8  # 稍微紧凑但可接受
        else:
            # 容量过大，分数递减
            excess_ratio = room_capacity / ideal_max
            return max(0.3, 1.0 / excess_ratio)
```

---

**代码说明**：

1. **前端代码**：采用Vue.js 3 + TypeScript开发，实现了智能对话界面和语音交互功能
2. **后端代码**：基于FastAPI框架，集成AI服务和语音处理能力
3. **数据模型**：使用SQLAlchemy ORM定义完整的数据结构
4. **API接口**：RESTful API设计，支持智能对话和语音处理
5. **工具函数**：自然语言时间解析和智能推荐算法等核心功能实现

所有代码均为原创开发，具有完全自主知识产权，体现了系统的技术创新和实用价值。